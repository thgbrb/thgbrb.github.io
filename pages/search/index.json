[{"content":"Defini√ß√£o de log estruturado Log estruturado √© uma t√©cnica de registro de eventos em sistemas de computador, que envolve o armazenamento de informa√ß√µes em um formato padronizado e organizado, facilitando a an√°lise e busca de informa√ß√µes espec√≠ficas. Em contraste com o log n√£o estruturado, onde as informa√ß√µes s√£o gravadas em texto simples e sem formata√ß√£o, o log estruturado segue uma estrutura definida, geralmente em formato de chave-valor. Essa estrutura permite que os dados sejam organizados de maneira coerente e significativa, tornando mais f√°cil a an√°lise de problemas e a identifica√ß√£o de padr√µes. Al√©m disso, o log estruturado pode ser armazenado em v√°rios tipos de banco de dados, permitindo um acesso mais r√°pido e eficiente √†s informa√ß√µes de registro. Em resumo, o log estruturado √© uma t√©cnica importante para melhorar a visibilidade e a confiabilidade de sistemas de computador, tornando mais f√°cil a identifica√ß√£o e resolu√ß√£o de problemas.\nExemplo de logs Exemplo de log n√£o estruturado\n1 2 3 4 5 2023-04-18 14:32:45,943 [INFO] Aplicativo iniciado 2023-04-18 14:32:46,156 [DEBUG] Conex√£o com banco de dados estabelecida com sucesso 2023-04-18 14:33:02,234 [ERROR] Erro ao processar solicita√ß√£o de login do usu√°rio \u0026#34;steve_jobs\u0026#34; 2023-04-18 14:34:17,345 [WARN] Quantidade de mem√≥ria dispon√≠vel abaixo do limite m√≠nimo 2023-04-18 14:35:09,876 [INFO] Aplicativo encerrado Nesse exemplo, as informa√ß√µes s√£o gravadas em texto simples e sem formata√ß√£o definida. As linhas do log cont√™m um carimbo de data/hora, um n√≠vel de log (INFO, DEBUG, ERROR, WARN), e uma mensagem descritiva sobre o evento que ocorreu. No entanto, n√£o h√° estrutura definida para as informa√ß√µes, tornando dif√≠cil a an√°lise e busca de informa√ß√µes espec√≠ficas, especialmente em grandes conjuntos de dados de log.\nExemplo de log estruturado\n1 2 3 4 5 {\u0026#34;timestamp\u0026#34;: \u0026#34;2023-04-18T14:32:45.943Z\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Aplicativo iniciado\u0026#34;} {\u0026#34;timestamp\u0026#34;: \u0026#34;2023-04-18T14:32:46.156Z\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;DEBUG\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Conex√£o com banco de dados estabelecida com sucesso\u0026#34;} {\u0026#34;timestamp\u0026#34;: \u0026#34;2023-04-18T14:33:02.234Z\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;ERROR\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Erro ao processar solicita√ß√£o de login\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;steve_jobs\u0026#34;} {\u0026#34;timestamp\u0026#34;: \u0026#34;2023-04-18T14:34:17.345Z\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;WARN\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Quantidade de mem√≥ria dispon√≠vel abaixo do limite m√≠nimo\u0026#34;} {\u0026#34;timestamp\u0026#34;: \u0026#34;2023-04-18T14:35:09.876Z\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Aplicativo encerrado\u0026#34;} Observe que agora h√° um campo adicional chamado \u0026ldquo;username\u0026rdquo; que foi adicionado ao evento de log que gerou o erro. O valor \u0026ldquo;joao\u0026rdquo; que antes estava na mensagem agora foi transformado em uma propriedade, tornando a informa√ß√£o mais facilmente acess√≠vel e busc√°vel. Essa √© uma das principais vantagens do log estruturado: a capacidade de separar as informa√ß√µes em campos espec√≠ficos para que possam ser facilmente pesquisadas e analisadas.\nO que √© o MessageTemplate no Serilog O MessageTemplate no Serilog √© um recurso que permite que as mensagens de log sejam formatadas de maneira mais sofisticada e flex√≠vel. Ele √© um modelo de mensagem que define uma string de formato contendo marcadores de posi√ß√£o que podem ser substitu√≠dos por valores din√¢micos durante a grava√ß√£o do log. Em vez de simplesmente gravar uma mensagem de log em uma string fixa, o MessageTemplate permite que as mensagens de log sejam formatadas de maneira personalizada, com base em informa√ß√µes espec√≠ficas do evento de log. O uso de MessageTemplates tamb√©m pode melhorar o desempenho, reduzindo a sobrecarga de aloca√ß√£o de mem√≥ria e a convers√£o de tipos, uma vez que os valores de substitui√ß√£o s√£o processados de forma mais eficiente do que se fossem concatenados em uma √∫nica string fixa. Em resumo, o MessageTemplate √© uma ferramenta √∫til para tornar a grava√ß√£o de logs mais flex√≠vel, leg√≠vel e eficiente.\nPara utilizar o MessageTemplate do Serilog, √© necess√°rio definir uma string de formato que contenha marcadores de posi√ß√£o para os valores que ser√£o substitu√≠dos durante a grava√ß√£o do log. Os marcadores de posi√ß√£o s√£o definidos entre chaves e podem conter um nome opcional para identificar o valor que ser√° substitu√≠do.\n1 2 3 _log.Debug(\u0026#34;{Count} eventos para serem emitidos\u0026#34;, _filaEventos.Count); // {\u0026#34;Count\u0026#34;:10, \u0026#34;Message\u0026#34;:\u0026#34;10 eventos para serem emitidos\u0026#34;, \u0026#34;Level\u0026#34;:\u0026#34;Debug\u0026#34;, \u0026#34;Timestamp\u0026#34;:\u0026#34;2023-04-19T15:30:00.0000000Z\u0026#34;} Neste exemplo, a propriedade \u0026ldquo;Count\u0026rdquo; √© adicionada ao log estruturado para representar o n√∫mero de eventos pendentes na fila. O valor dessa propriedade √© 10, que √© o valor de _filaEventos.Count. Al√©m disso, a mensagem de log tamb√©m √© inclu√≠da na propriedade \u0026ldquo;Message\u0026rdquo;, e o n√≠vel de log \u0026ldquo;Debug\u0026rdquo; √© registrado na propriedade \u0026ldquo;Level\u0026rdquo;. A propriedade \u0026ldquo;Timestamp\u0026rdquo; cont√©m a data e hora em que o log foi registrado.\nCom essa sa√≠da, √© poss√≠vel realizar an√°lises mais precisas e filtrar logs de maneira mais eficiente, utilizando as propriedades definidas no log estruturado. O uso de logs estruturados √© uma pr√°tica recomendada para melhorar a qualidade e a efici√™ncia da gest√£o de logs em aplica√ß√µes e sistemas.\nErro comum ao gerar log estruturado Um erro comum ao gerar uma mensagem de log √© ignorar o messageTemplate. No exemplo abaixo √© feito a concatena√ß√£o da propriedade Count com a string definida. Essa pr√°tica n√£o permite que o log seja indexado ou que seja utilizado para gera√ß√£o de m√©tricas quantitativas. Tamb√©m √© observado uma ineficiencia na aloca√ß√£o de mem√≥ria, onde ocorre uma opera√ß√£o de box/unbox do int e a aloca√ß√£o de uma nova string.\n1 2 3 _log.Debug($\u0026#34;{_filaEventos.Count} eventos para serem emitidos\u0026#34;); // [Debug] 10 eventos para serem emitidos Conclus√£o Em conclus√£o, o MessageTemplate do Serilog √© uma ferramenta poderosa para personalizar e formatar mensagens de log de maneira estruturada. Ao definir uma string de formato com marcadores de posi√ß√£o, √© poss√≠vel adicionar propriedades significativas aos logs que permitem an√°lises precisas e filtragem eficiente.\nü§Ø Informa√ß√£o\nConhe√ßa mais sobre o messagem template em https://messagetemplates.org\n","date":"2023-04-19T00:00:00Z","image":"https://joganacontadainfra.com.br/p/serilog-message-template/jatin-jangid-1f0DB1u7p8Q-unsplash_hu_68d013efdd1b643f.jpg","permalink":"https://joganacontadainfra.com.br/p/serilog-message-template/","title":"Utilizando MessageTemplate em log estruturado."},{"content":"Yield return Dado uma lista de n elementos, o yield return retorna o pr√≥ximo valor da sequ√™ncia. O yield return trabalha no topo da interface IEnumerable, que √© o contrato da implementa√ß√£o do iterator pattern na classe Enumerable. O iterator pattern √© um padr√£o presente na maioria das linguagens de prop√≥sito geral e/ou orientada a objetos e √© utilizado para atravessar uma cole√ß√£o de objetos. Essa travessia permite desacoplar algoritmos da intera√ß√£o da lista.\nUm objeto que herda de Agggregate agrega objetos. Esse objeto do tipo Aggregate √© interado pelo objeto do tipo ConcreteIterator.\nFonte: https://en.wikipedia.org/wiki/Iterator_pattern#/media/File:Iterator_UML_class_diagram.svg O problema com filtros Um padr√£o t√≠pico na manipula√ß√£o de listas √© filtros de listas. No exemplo abaixo, recebemos uma lista de n√∫meros onde os n√∫meros pares s√£o adicionados a uma nova lista e ent√£o s√£o retornados.\n1 2 3 4 5 6 7 8 9 10 11 12 13 private IEnumerable\u0026lt;int\u0026gt; FilteringWithout(int iterations) { var range = Enumerable.Range(1, iterations); var evenList = new List\u0026lt;int\u0026gt;(); foreach (var number in range) { if (number % 2 == 0) evenList.Add(number); } return evenList; } O c√≥digo est√° correto e funciona. Se essa lista for pequena, √© prov√°vel que n√£o cause press√£o no GC, por√©m, quando a quantidade de objetos aumenta as coisas ficam interessantes.\nUsando o Yield return O exemplo abaixo demonstra o yield return na pr√°tica. Como diz a sua defini√ß√£o, ele retorna o pr√≥ximo elemento da lista. Uma vez que ele sempre retorna o pr√≥ximo elemento da lista, n√£o √© necess√°rio fazer as aloca√ß√µes de mem√≥ria que observamos na solu√ß√£o anterior, onde cada objeto do resultado √© adicionado a uma lista tempor√°ria que √© retornada. Essa mudan√ßa de comportamento causa um impacto tremendo de press√£o no GC.\n1 2 3 4 5 6 7 8 9 10 private IEnumerable\u0026lt;int\u0026gt; FilterWith(int iterations) { var range = Enumerable.Range(1, iterations); foreach (var number in range) { if (number % 2 == 0) yield return number; } } Benchmark com yield return Os exemplos acima foram executados com o BenchmarkDotNet, onde √© poss√≠vel observar o efeito da press√£o no GC no incremento da lista. A partir da de 10_000 intera√ß√µes √© observado a promo√ß√£o de objetos para a GEN1. Quando a cole√ß√£o √© incrementada para 100_000 as coisas ficam mais interessantes. Nesse cen√°rio √© observado a promo√ß√£o dos objetos para GEN2. Em um cen√°rio real isso aumenta a chance de uma coleta full do GC. Interessante observar tamb√©m que com a utiliza√ß√£o do yield return a aloca√ß√£o de mem√≥ria n√£o muda no incremento da lista. Isso porque o interador retorna um objeto por vez ao inv√©s de acumul√°-los em uma lista tempor√°ria. A aloca√ß√£o de mem√≥ria no cen√°rio sem yield return e com 100_000_000 de intera√ß√µes √© de 536MB.\nCen√°rios reais Um cen√°rio muito comum de encontrar press√£o no GC por intera√ß√µes de cole√ß√µes s√£o em processos que manipulam arquivos de dados, tais como csv ou txt. As implementa√ß√µes mais comuns tratam cada linha do arquivo como um objeto em uma lista. O arquivo √© lido, as linhas criam objetos que s√£o adicionados em uma lista. Posteriormente s√£o aplicadas manipula√ß√µes que podem gerar outras listas intermedi√°rias. A utiliza√ß√£o do yield return na importa√ß√£o de arquivos habilita a leitura de blocos de linhas que s√£o manipulados ao serem recebidos.\nConclus√£o A manipula√ß√£o de cole√ß√µes faz parte do dia a dia do desenvolvedor e merece muita aten√ß√£o. √â essencial considerar o volume de objetos que ser√£o manipulados, isso pode se transformar em um ofensor. Sempre que poss√≠vel utilize yield return nos retornos para aliviar a press√£o no GC. Pequenas mudan√ßas no estilo de codifica√ß√£o podem evitar ofensores, economizar recursos computacionais e entregar uma aplica√ß√£o mais perform√°tica.\nFontes: https://github.com/thgbrb/yield-return\n","date":"2023-02-05T00:00:00Z","image":"https://joganacontadainfra.com.br/p/yield-return/kelly-sikkema-M6dAnUgiOlQ-unsplash_hu_6733f08d898107c0.jpg","permalink":"https://joganacontadainfra.com.br/p/yield-return/","title":"Uso otimizado de Enumerables com yield return"},{"content":"A facilidade do uso das clouds permite que em poucos minutos uma aplica√ß√£o esteja dispon√≠vel e publicada, por√©m demanda um esfor√ßo para que isso aconte√ßa. Esse esfor√ßo envolve normalmente o provisionamento de ambientes e a sua publica√ß√£o a cada altera√ß√£o. Uma alternativa para exposi√ß√£o de servi√ßos √© rotear o acesso diretamente para a aplica√ß√£o local. Essa estrat√©gia elimina a necessidade de publica√ß√µes para testes e /ou valida√ß√µes. Sem o uso de ferramentas esse processo tende a ser demorado, manual e pouco eficiente.\nNgrok - Ingress-as-a-Service O Ngrok √© uma ferramenta super esperta que, atrav√©s da utiliza√ß√£o de um agente local, permite redirecionar todo o tr√°fego de uma DNS tempor√£rio para uma porta local espec√≠fica. Isso significa, que toda a requisi√ß√£o feita para esse DNS tempor√°rio √© redirecionada para a porta local do seu dispositivo.\nWebhook Durante a integra√ß√£o como o webhook do Azure DevOps foi necess√°rio expor uma URL v√°lida para receber os eventos do Azure DevOps. Para agilizar o processo do laborat√≥rio inicial, utilizei um DNS tempor√°rio criado pelo ngrok para que a aplica√ß√£o rodando localmente fosse sensibilizada.\nPara ser sensibilizado pelo webhook do Azure DevOps coloquei a aplica√ß√£o para executar localmente na porta 5084.\n1 2 info: Microsoft.Hosting.Lifetime[14] Now listening on: http://localhost:5084 Uma vez que o ngrok est√° instalado com sua chave de api configurada, basta executar o agente para criar o DNS tempor√°rio e iniciar o redirecionamento.\n1 ngrok http 5084 Em alguns segundos o redirecionamento est√° conclu√≠do.\nNo teste abaixo, observamos que a requisi√ß√£o de teste feita pelo painel de service hook do Azure DevOps √© recebida diretamente na aplica√ß√£o que est√° rodando localmente em modo debug.\nConclus√£o Em cen√°rios de laborat√≥rios, testes ou integra√ß√µes r√°pidas a estrat√©gia com o ngrok √© uma excelente alternativa para evitar o investimento de tempo e energia em itens de infraestrutura que estejam fora do escopo. O ngrok est√° dispon√≠vel para Windows, Mac e Linux e a sua licen√ßa free permite a cria√ß√£o de um redirecionamento.\nüëâ Dica ‚ò†Ô∏è\nA instala√ß√£o do ngrok est√° dispon√≠vel nos principais gerenciadores de pacotes.\nbrew install ngrok/ngrok/ngrok choco install ngrok snap install ngrok ","date":"2023-01-28T00:00:00Z","image":"https://joganacontadainfra.com.br/p/ngrok-dns-publico-temporario/pablo-arroyo-_SEbdtH4ZLM-unsplash_hu_c48941e67345ab3c.jpg","permalink":"https://joganacontadainfra.com.br/p/ngrok-dns-publico-temporario/","title":"Ingress-as-a-Service - Exposi√ß√£o de servi√ßos locais"},{"content":"Quando atuamos em sistemas complexos facilmente percebemos a quantidade de pessoas que atuaram apenas observando os estilos de codifica√ß√£o (inclusive os mais peculiares). Cada pessoa possui suas habilidades e experi√™ncias, e isso influencia diretamente em como o c√≥digo √© escrito. Uma das estrat√©gias para minimizar esse impacto √© reduzir ao m√°ximo a complexidade cognitiva.\nBloco de exemplo Esse bloco de c√≥digo tem uma pontua√ß√£o complexidade cognitiva alta, o que √© esperado dado a quantidade de desvios dentro de um looping. O primeiro destaque vai para as branchs else que s√£o redundantes, uma vez que a condi√ß√£o √© retornada caso n√£o seja verdadeira.\n1 2 3 4 5 6 7 8 9 10 11 12 13 foreach (var item in request.Apis) { if (!await _certificationRepository.FindApiAsync(item.IdApi)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_FOUND, GlobalizationConstants.ApiNaoEncontrada.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); else if (!await _certificationRepository.ActiveApiAsync(item.IdApi)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_ACTIVE, GlobalizationConstants.ApiNaoEstaAtiva.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); else if (!await _certificationRepository.CertificationApiAsync(item.IdApi)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_CERTIFICATION, GlobalizationConstants.ApiNaoExigeCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); else if (!await _certificationRepository.ScenariosApiAsync(item.IdApi)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_SCENARIOS, GlobalizationConstants.ApiNaoPossuiCenariosParaCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); else if (!await _developerRepository.DeveloperCredentials(developer.Id)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.DEV_NOT_CREDENTIALS, GlobalizationConstants.DesenvolvedorNaoPossuiCredenciais.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); } No C# high-level gerado pelo compilador a partir de um IL Release, observamos que as branchs foram removidas.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 foreach (StartCertificationDeveloperRequest api in request.Apis) { item = api; if (!await developerHandler._certificationRepository.FindApiAsync(item.IdApi)) return developerHandler.Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao((string) null, \u0026#34;API_NOT_FOUND\u0026#34;, \u0026#34;ApiNaoEncontrada\u0026#34;.Resource(), \u0026#34;MensagemPadraoErroLoremIpsum\u0026#34;.Resource())); if (!await developerHandler._certificationRepository.ActiveApiAsync(item.IdApi)) return developerHandler.Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao((string) null, \u0026#34;API_NOT_ACTIVE\u0026#34;, \u0026#34;ApiNaoEstaAtiva\u0026#34;.Resource(), \u0026#34;MensagemPadraoErroLoremIpsum\u0026#34;.Resource())); if (!await developerHandler._certificationRepository.CertificationApiAsync(item.IdApi)) return developerHandler.Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao((string) null, \u0026#34;API_NOT_CERTIFICATION\u0026#34;, \u0026#34;ApiNaoExigeCertificacao\u0026#34;.Resource(), \u0026#34;MensagemPadraoErroLoremIpsum\u0026#34;.Resource())); if (!await developerHandler._certificationRepository.ScenariosApiAsync(item.IdApi)) return developerHandler.Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao((string) null, \u0026#34;API_NOT_SCENARIOS\u0026#34;, \u0026#34;ApiNaoPossuiCenariosParaCertificacao\u0026#34;.Resource(), \u0026#34;MensagemPadraoErroLoremIpsum\u0026#34;.Resource())); if (!await developerHandler._developerRepository.DeveloperCredentials(developer.Id)) return developerHandler.Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao((string) null, \u0026#34;DEV_NOT_CREDENTIALS\u0026#34;, \u0026#34;DesenvolvedorNaoPossuiCredenciais\u0026#34;.Resource(), \u0026#34;MensagemPadraoErroLoremIpsum\u0026#34;.Resource())); item = (StartCertificationDeveloperRequest) null; } Os compiladores modernos s√£o h√°beis para otimizar boa parte do c√≥digo que √© escrito. Al√©m disso, as linguagens modernas entregam syntax-sugars para facilitar a leitura e entendimento do c√≥digo. No exemplo acima podemos observar por exemplo, que al√©m de remover as branchs else redundante, o compilador tamb√©m substituiu as constantes por seus valores.\nEscreva c√≥digo para humanos preferencialmente Para que um codebase evolua de forma saud√°vel, precisamos dar prefer√™ncia para a escrita de c√≥digo para humanos e n√£o para compiladores. Escrever um c√≥digo complexo, que privilegia o desempenho, deve ser algo que fa√ßa sentido e principalmente, tenha m√©tricas e n√∫meros que justifiquem isso.\nO exemplo abaixo √© a parte de uma solu√ß√£o complexa que utiliza estrat√©gia de bit-field para fazer classifica√ß√µes. Essa solu√ß√£o foi desenvolvida para resolver um problema muito espec√≠fico que demandava performance e controle do uso de recursos computacionais. Al√©m da documenta√ß√£o em c√≥digo, foi necess√°ria uma p√°gina inteira de wiki para garantir o seu entendimento e evolu√ß√£o.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 11100000000000000000000000000000-11100000000000000000000000101111 | 1F 1P 0-3O // 11100000000000000000000000111000-11100000000000000000000000111111 | 2P 1F 0O-3O if (value is \u0026gt;= 0xE0000000 and \u0026lt;= 0xE000002F || value is \u0026gt;= 0xE0000038 and \u0026lt;= 0xE000003F) { _classificacaoManager.EnqueueClienteParaClassificacao(data.Key); while (!_classificacaoManager.Cpfs.TryRemove(data.Key, out _)) spinner.SpinOnce(-1); _contadores.CpfEnviadoParaClassificacaoEspeculativa(); _logger.Debug($\u0026#34;CPF enviado para classifica√ß√£o especulativamente Reason: {data.Value.BitsToString()}\u0026#34;); } C√≥digos que privilegiam performance tendem a possuir complexidade cognitiva alta!\nComo deixar o exemplo mais leg√≠vel Para exercitar a redu√ß√£o da complexidade cognitiva vamos refatorar o bloco de c√≥digo do in√≠cio desse artigo. A primeira a√ß√£o √© a quebra de linha utilizando uma recomenda√ß√£o de 120 colunas. Tamb√©m adicionamos uma quebra de linha entre os blocos IF. Essa altera√ß√£o melhora a leitura do c√≥digo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 foreach (var item in request.Apis) { if (!await _certificationRepository.FindApiAsync(item.IdApi)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_FOUND, GlobalizationConstants.ApiNaoEncontrada.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); if (!await _certificationRepository.ActiveApiAsync(item.IdApi)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_ACTIVE, GlobalizationConstants.ApiNaoEstaAtiva.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); if (!await _certificationRepository.CertificationApiAsync(item.IdApi)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_CERTIFICATION, GlobalizationConstants.ApiNaoExigeCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); if (!await _certificationRepository.ScenariosApiAsync(item.IdApi)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_SCENARIOS, GlobalizationConstants.ApiNaoPossuiCenariosParaCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); if (!await _developerRepository.DeveloperCredentials(developer.Id)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.DEV_NOT_CREDENTIALS, GlobalizationConstants.DesenvolvedorNaoPossuiCredenciais.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); } A boa pr√°tica recomenda que o IF teste uma condi√ß√£o TRUE preferencialmente, o que reduz complexidade cognitiva. Quando invertemos a condi√ß√£o IF precisamos encadear os IFs, o que aumenta muiti a complexidade.\nUma boa pr√°tica √© uma recomenda√ß√£o e n√£o uma regra.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 foreach (var item in request.Apis) { if (await _certificationRepository.FindApiAsync(item.IdApi)) { if (await _certificationRepository.ActiveApiAsync(item.IdApi)) { if (await _certificationRepository.CertificationApiAsync(item.IdApi)) { if (await _certificationRepository.ScenariosApiAsync(item.IdApi)) { if (!await _developerRepository.DeveloperCredentials(developer.Id)) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.DEV_NOT_CREDENTIALS, GlobalizationConstants.DesenvolvedorNaoPossuiCredenciais.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); } else { return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_SCENARIOS, GlobalizationConstants.ApiNaoPossuiCenariosParaCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); } } else { return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_CERTIFICATION, GlobalizationConstants.ApiNaoExigeCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); } } else { return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_ACTIVE, GlobalizationConstants.ApiNaoEstaAtiva.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); } } else return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_FOUND, GlobalizationConstants.ApiNaoEncontrada.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); } No in√≠cio do looping, √© percebido que a propriedade Apis √© uma lista dentro de um objeto que pode ser null. Nesse fluxo seria gerado uma NullException. De acordo com a boa pr√°tica, deve ser verificado se o objeto √© nulo antes do acesso.\n1 2 3 4 if (request.Apis != null) { foreach (var item in request.Apis) (...) Analisando as chamadas de reposit√≥rio √© observado que cada chamada faz um SELECT no banco de forma independente. Al√©m disso, essas chamadas n√£o est√£o possui depend√™ncias entre si. Isso significa que elas podem ser executadas em paralelo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 foreach (var item in request.Apis) { var findApiAsync = _certificationRepository.FindApiAsync(item.IdApi); var activeApiAsync = _certificationRepository.ActiveApiAsync(item.IdApi); var certificationApiAsync= _certificationRepository.CertificationApiAsync(item.IdApi); var scenariosApiAsync = _certificationRepository.ScenariosApiAsync(item.IdApi); var developerCredentialsAsync = _developerRepository.DeveloperCredentials(developer.Id); await Task.WhenAll(new Task[] { findApiAsync, activeApiAsync, certificationApiAsync, scenariosApiAsync, developerCredentialsAsync }); if (! await findApiAsync) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_FOUND, GlobalizationConstants.ApiNaoEncontrada.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); if (!await activeApiAsync) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_ACTIVE, GlobalizationConstants.ApiNaoEstaAtiva.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); if (!await certificationApiAsync) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_CERTIFICATION, GlobalizationConstants.ApiNaoExigeCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); if (!await scenariosApiAsync) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.API_NOT_SCENARIOS, GlobalizationConstants.ApiNaoPossuiCenariosParaCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); if (!await developerCredentialsAsync) return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, StatusOperacaoConstants.DEV_NOT_CREDENTIALS, GlobalizationConstants.DesenvolvedorNaoPossuiCredenciais.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource())); } Analisando o c√≥digo observamos que os retornos das verifica√ß√µes s√£o objetos de erro. Esse cen√°rio permite extrair a constru√ß√£o do objeto de erro para um m√©todo. Uma estrat√©gia melhor seria implementar essas constru√ß√µes no pr√≥prio objeto de erro utilizando o factory pattern.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 CommandResponse\u0026lt;Result\u0026lt;StartCertificationDeveloperResult\u0026gt;\u0026gt; CreateResponseInternal(string statusOperacao, string mensagemAmigavel, string mensagemTecnica) { return Response(Result\u0026lt;StartCertificationDeveloperResult\u0026gt;.RetornarErrosDeValidacao(null, statusOperacao, mensagemAmigavel, mensagemTecnica)); } _unitOfWork.Begin(); foreach (var item in request.Apis) { var findApiAsync = _certificationRepository.FindApiAsync(item.IdApi); var activeApiAsync = _certificationRepository.ActiveApiAsync(item.IdApi); var certificationApiAsync = _certificationRepository.CertificationApiAsync(item.IdApi); var scenariosApiAsync = _certificationRepository.ScenariosApiAsync(item.IdApi); var developerCredentialsAsync = _developerRepository.DeveloperCredentials(developer.Id); await Task.WhenAll(new Task[] { findApiAsync, activeApiAsync, certificationApiAsync, scenariosApiAsync, developerCredentialsAsync }); if (!await findApiAsync) return CreateResponseInternal( StatusOperacaoConstants.API_NOT_FOUND, GlobalizationConstants.ApiNaoEncontrada.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource()); if (!await activeApiAsync) return CreateResponseInternal( StatusOperacaoConstants.API_NOT_ACTIVE, GlobalizationConstants.ApiNaoEstaAtiva.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource()); if (!await certificationApiAsync) return CreateResponseInternal( StatusOperacaoConstants.API_NOT_CERTIFICATION, GlobalizationConstants.ApiNaoExigeCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource()); if (!await scenariosApiAsync) return CreateResponseInternal( StatusOperacaoConstants.API_NOT_SCENARIOS, GlobalizationConstants.ApiNaoPossuiCenariosParaCertificacao.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource()); if (!await developerCredentialsAsync) return CreateResponseInternal( StatusOperacaoConstants.DEV_NOT_CREDENTIALS, GlobalizationConstants.DesenvolvedorNaoPossuiCredenciais.Resource(), GlobalizationConstants.MensagemPadraoErroLoremIpsum.Resource()); } Ap√≥s a an√°lise e refatora√ß√£o do m√©todo conseguimos obter:\nRedu√ß√£o da complexidade cognitiva; Paralelismo nas chamadas para banco de dados; Tratamento de null exception; Encapsulamento de constru√ß√£o de objetos; Conclus√£o A complexidade cognitiva √© um ofensor na manuten√ß√£o e evolu√ß√£o de um codebase, seja por gerar ru√≠dos no c√≥digo, por n√£o utilizar os recursos da linguagem ou at√© mesmo por privilegiar performance. Aplica√ß√µes empresariais s√£o complexas por natureza e a elimina√ß√£o da complexidade √© quase uma utopia, por√©m com o investimento de algum tempo na an√°lise, aplicando os recursos da linguagem e aplicando t√©cnicas de programa√ß√£o √© poss√≠vel reduzir consideravelmente o impacto desse ofensor.\nüëâ Dica ‚ò†Ô∏è\nPor padr√£o, escreva c√≥digo para humanos e n√£o para compiladores.\nüëâ Dica2 ‚ò†Ô∏è\nInvista 18 minutos do seu dia para conhecer e se aprofundar na sua linguagem principal. Parace pouco, mas em um ano isso representa ~90h :)\n","date":"2023-01-16T00:00:00Z","image":"https://joganacontadainfra.com.br/p/evolucao-manutencao-codebase/linh-ha-KN8W0Q8H3gI-unsplash_hu_c551d1c5e109ab7c.jpg","permalink":"https://joganacontadainfra.com.br/p/evolucao-manutencao-codebase/","title":"Manuten√ß√£o e evolu√ß√£o de codebase"},{"content":"Eliding Task Por padr√£o, quando uma opera√ß√£o de IO Bound √© executada, o await da task acontece no mesmo m√©todo que invocou a chamada. Em alguns cen√°rios, ap√≥s o await o resultado dessa task √© retornado diretamente para o m√©todo que originou o fluxo. Um exemplo comum desse cen√°rio √© quando uma API com arquitetura em layers faz uma chamada ao banco de dados, passando por todas as camadas e retorna o valor da consulta em um response. A proposta do eliding task √© que ao inv√©s de fazer o await da task no mesmo m√©todo onde a task √© iniciada, √© que isso seja feito no m√©todo que originou o fluxo.\nExemplo No exemplo proposto nesse artigo, √© feito uma resolu√ß√£o de IP para o dom√≠nio localhost, atrav√©s de uma estrutura que representa um projeto n-layers. Quando o await √© feito sem eliding, ele ocorre na camada mais inferior.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 namespace IOBoundContext { public class NetworkTools { public async Task\u0026lt;string\u0026gt; GetHostNameEntryAsync(string hostname) { var ipHostInfo = await Dns.GetHostEntryAsync(hostname); return ipHostInfo.AddressList[0].ToString(); } public Task\u0026lt;IPHostEntry\u0026gt; ElidingGetHostNameEntryAsync(string hostname) { return Dns.GetHostEntryAsync(hostname); } } } J√° no m√©todo que faz o eliding, ele retorna a task, sem fazer o await. Observe que a assinatura do m√©todo muda, perdendo o sufixo async. O retorno tamb√©m muda, retornando o objeto IPHostEntry e n√£o mais uma string com o retorno tratado.\n1 public Task\u0026lt;IPHostEntry\u0026gt; ElidingGetHostNameEntryAsync(string hostname) Trade-offs Como toda t√©cnica de otimiza√ß√£o, existem trade-offs entre legibilidade e manutenibilidade de c√≥digo e performance. A t√©cnica de eliding otimiza aloca√ß√£o de mem√≥ria. O impacto ocorre no stacktrace de expcetions * e responsabilidade √∫nica.\nBenef√≠cio: Aloca√ß√£o de mem√≥ria Para que uma chamada IO bound ocorra sem bloqueio de threads, √© necess√°rio que a chamada seja async-all-the-way, ou seja, do m√©todo chamador at√© a chamada de mais baixo n√≠vel na aplica√ß√£o, devem ser chamadas marcadas como ass√≠ncronas. No benchmark abaixo √© poss√≠vel observar a diferen√ßa na aloca√ß√£o de mem√≥ria com a t√©cnica.\nMethod Runtime Allocated native memory Gen0 Allocated NonElidingTask .NET Framework 4.7.2 - 0.4883 4532 B ElidingTask .NET Framework 4.7.2 - - 2804 B NonElidingTask .NET 6.0 11,192 B - 1729 B ElidingTask .NET 6.0 11,192 B - 897 B O benchamark foi feito com .NET Framework 4.7.2 e .NET 6, onde √© poss√≠vel observar a evolu√ß√£o do framework.\nTrade-off 1: Stacktrace de exceptions Como o await da task n√£o acontece no m√©todo que iniciou a chamada ass√≠ncrona existe uma altera√ß√£o na ordem do stracktrace de exceptions. Observe que a exception de uma task com eliding modifica o call stack.\nException no Eliding no .NET Framework 4.7.1 1 2 3 4 5 6 7 8 9 10 11 12 Unhandled Exception: System.ArgumentNullException: Value cannot be null. Parameter name: hostName at System.Net.Dns.HostResolutionBeginHelper(String hostName, Boolean justReturnParsedIp, Boolean flowContext, Boolean includeIPv6, Boolean throwOnIPAny, AsyncCallback requestCallback, Object state) at System.Net.Dns.BeginGetHostEntry(String hostNameOrAddress, AsyncCallback requestCallback, Object stateObject) at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl[TArg1](Func`4 beginMethod, Func`2 endFunction, Action`1 endAction, TArg1 arg1, Object state, TaskCreationOptions creationOptions) at System.Net.Dns.GetHostEntryAsync(String hostNameOrAddress) at Benchmark.TaskNonElidingVsEliding.\u0026lt;ElidingTask\u0026gt;d__3.MoveNext() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 91 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Benchmark.Program.ElidingTaskWithException() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 38 at Benchmark.Program.Main(String[] args) in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 25 Quando n√£o √© realizado o eliding, o call stack mostra todas as chamadas.\nException sem Eliding no .NET Framework 4.7.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Unhandled Exception: System.ArgumentNullException: Value cannot be null. Parameter name: hostName at System.Net.Dns.HostResolutionBeginHelper(String hostName, Boolean justReturnParsedIp, Boolean flowContext, Boolean includeIPv6, Boolean throwOnIPAny, AsyncCallback requestCallback, Object state) at System.Net.Dns.BeginGetHostEntry(String hostNameOrAddress, AsyncCallback requestCallback, Object stateObject) at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl[TArg1](Func`4 beginMethod, Func`2 endFunction, Action`1 endAction, TArg1 arg1, Object state, TaskCreationOptions creationOptions) at System.Net.Dns.GetHostEntryAsync(String hostNameOrAddress) at IOBoundContext.NetworkTools.\u0026lt;GetHostNameEntryAsync\u0026gt;d__0.MoveNext() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Simulation\\IOBoundContext\\NetworkTools.cs:line 11 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Application.DoWork.\u0026lt;GetHostnameIpAddressAsync\u0026gt;d__0.MoveNext() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Simulation\\Application\\DoWork.cs:line 13 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Benchmark.TaskNonElidingVsEliding.\u0026lt;NonElidingTask\u0026gt;d__2.MoveNext() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 83 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Benchmark.Program.NonElidingTaskWithException() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 53 at Benchmark.Program.Main(String[] args) in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 25 .NET 6 e task eliding\nDurante o benchmark observei que essa issue foi tratada no .NET6, onde o call stack √© exibido corretamente com a t√©cnica do eliding.\nException sem Eliding no .NET 6 1 2 3 4 5 6 7 8 9 Unhandled exception. System.ArgumentNullException: Value cannot be null. (Parameter \u0026#39;hostName\u0026#39;) at System.Net.Dns.GetHostEntryOrAddressesCoreAsync(String hostName, Boolean justReturnParsedIp, Boolean throwOnIIPAny, Boolean justAddresses, AddressFamily family, CancellationToken cancellationToken) at System.Net.Dns.GetHostEntryAsync(String hostNameOrAddress, AddressFamily family, CancellationToken cancellationToken) at System.Net.Dns.GetHostEntryAsync(String hostNameOrAddress) at IOBoundContext.NetworkTools.GetHostNameEntryAsync(String hostname) in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Simulation\\IOBoundContext\\NetworkTools.cs:line 11 at Application.DoWork.GetHostnameIpAddressAsync(String hostname) in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Simulation\\Application\\DoWork.cs:line 13 at Benchmark.TaskNonElidingVsEliding.NonElidingTask() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 83 at Benchmark.Program.NonElidingTaskWithException() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 52 at Benchmark.Program.Main(String[] args) in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 23 Exception com Eliding no .NET 6 1 2 3 4 5 6 7 8 9 Unhandled exception. System.ArgumentNullException: Value cannot be null. (Parameter \u0026#39;hostName\u0026#39;) at System.Net.Dns.GetHostEntryOrAddressesCoreAsync(String hostName, Boolean justReturnParsedIp, Boolean throwOnIIPAny, Boolean justAddresses, AddressFamily family, CancellationToken cancellationToken) at System.Net.Dns.GetHostEntryAsync(String hostNameOrAddress, AddressFamily family, CancellationToken cancellationToken) at System.Net.Dns.GetHostEntryAsync(String hostNameOrAddress) at IOBoundContext.NetworkTools.ElidingGetHostNameEntryAsync(String hostname) in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Simulation\\IOBoundContext\\NetworkTools.cs:line 18 at Application.DoWork.ElidingGetHostnameIpAddressAsync(String hostname) in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Simulation\\Application\\DoWork.cs:line 20 at Benchmark.TaskNonElidingVsEliding.ElidingTask() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 92 at Benchmark.Program.ElidingTaskWithException() in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 37 at Benchmark.Program.Main(String[] args) in D:\\repos\\c#\\asyncawaiteliding\\BenchmarkTaskEliding\\Benchmark\\Program.cs:line 21 Trade-off 2: Responsabilidade √∫nica Quando o eliding acontece, a task √© retornada sem unwrap, ou seja, ela retorna o objeto do n√≠vel mais baixo, sem tratamento. Esse comportamento, transfere a responsabilidade do tratamento do retorno para o m√©todo chamador, ou seja, o retorno √© tratado em uma camada diferente de onde ele foi gerado. Em uma aplica√ß√£o enterprise, isso significa que aplica√ß√£o de uma regra de neg√≥cio no retorno poderia ser movida para uma outra camada (ex: camada de apresenta√ß√£o). Al√©m disso, objetos de infraestrutura (ex.: IPHostEntry) passam a ser referenciados em mais de uma camada ou at√© mesmo em camadas fora do seu contexto.\nTratamento do retorno na camada chamadora 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 namespace IOBoundContext { public class NetworkTools { public async Task\u0026lt;string\u0026gt; GetHostNameEntryAsync(string hostname) { var ipHostInfo = await Dns.GetHostEntryAsync(hostname); return ipHostInfo.AddressList[0].ToString(); } public Task\u0026lt;IPHostEntry\u0026gt; ElidingGetHostNameEntryAsync(string hostname) { return Dns.GetHostEntryAsync(hostname); } } } Tratamento do retorno na camada de alto n√≠vel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 namespace Benchmark { (...) [Benchmark] public async Task\u0026lt;string\u0026gt; NonElidingTask() { var app = new DoWork(); var result = await app.GetHostnameIpAddressAsync(_hostname); return result; } [Benchmark] public async Task\u0026lt;string\u0026gt; ElidingTask() { var app = new DoWork(); var result = await app.ElidingGetHostnameIpAddressAsync(_hostname); return result.AddressList[0].ToString(); } } } Conclus√£o Como toda t√©cnica de otimiza√ß√£o, existem trade-offs. O principal impacto da t√©cnica de eliding task √© a poss√≠vel quebra de responsabilidades, com a transfer√™ncia do tratamento do retorno para uma camada diferente da camada onde a chamada IO bound foi realizada. Antes de utilizar essa t√©cnica, √© essencial que sejam feitas medi√ß√µes e exista evid√™ncias que justifiquem o seu uso.\nüëâ Dica ‚ò†Ô∏è\nSe n√£o tiver medi√ß√µes e evid√™ncias que justifiquem o uso do eliding task, n√£o use :)\nü§Ø Informa√ß√£o\nReposit√≥rio: https://github.com/thgbrb/eliding-tasks\n","date":"2023-01-07T00:00:00Z","image":"https://joganacontadainfra.com.br/p/task-eliding-vs-noneliding/martins-zemlickis-NPFu4GfFZ7E-unsplash_hu_652f12847a194942.jpg","permalink":"https://joganacontadainfra.com.br/p/task-eliding-vs-noneliding/","title":"Comparando Task eliding e non-eliding"},{"content":"Conceito do Either O objetivo do Either √© representar um valor dado duas possibilidades. Um Either com valores A e B representar√° A ou B, nunca os dois.\nNesse exemplo, s poder√° representar uma string ou um int.\n1 2 3 4 5 let s = Left \u0026#34;foo\u0026#34; :: Either String Int Left \u0026#34;foo\u0026#34; let n = Right 3 :: Either String Int Right 3 Aplica√ß√£o Pr√°tica: Retornos de valida√ß√µes As estrat√©gias mais comuns de retornos de valida√ß√µes tratam dois tipos nos seus retornos, o sucesso e falha.\nNo exemplo abaixo, o m√©todo SalvarDadosAdicionais retorna o resultado de uma opera√ß√£o de neg√≥cio. Na sequencia √© verificado o tipo do retorno do objeto. Quando ocorre um ou mais erros, √© retornado o objeto do tipo ValidationResult, que √© um container para os erros. Quando ocorre um sucesso, √© retornado o objeto do tipo SalvarDadosAdicionaisCommandResult, que cont√©m o Id do objetivo persistido.\n1 2 3 4 5 6 var retorno = await _fluxoDadosAdicionaisService.SalvarDadosAdicionais(request); if (retorno is ValidationResult validationResult) return Response(validationResult); else return Response((SalvarDadosAdicionaisCommandResult)retorno); √â interessante observar que a valida√ß√£o do objeto est√° encapsulada no m√©todo SalvarDadosAdicionais, que herda da classe CommandResponse. Essa estrat√©gia n√£o deixa claro se o objeto √© v√°lido ou n√£o. Para identificar √© necess√°rio fazer o if de verifica√ß√£o de tipo. O CommandResponse tamb√©m faz if para verificar se existem propriedades nulas.\n1 2 3 4 5 6 7 8 9 10 11 public CommandResponse( TResult result, ValidationResult validationResult, HttpStatusCode? httpStatusCodeOnFailure) { this.Result = result; this.Errors = validationResult == null ? Array.Empty\u0026lt;ValidationFailure\u0026gt;() : validationResult.Errors.ToArray(); HttpStatusCodeOnFailure = httpStatusCodeOnFailure; } Solu√ß√£o com Either A solu√ß√£o Either traz clareza e remove verifica√ß√µes, uma vez que s√£o definidos os dois poss√≠veis tipos de retorno. No exemplo abaixo, ao inv√©s de retornarmos um tipo object, √© retornado um Either com os seus dois poss√≠veis valores.\n1 2 3 4 public Either\u0026lt;string, ArgumentNullException\u0026gt; ReturnsSuccessOrFail(string value) { return !string.IsNullOrEmpty(value) ? value : new ArgumentNullException(nameof(value)); } A assinatura do m√©todo deixa claro que ser√° retornado uma string ou uma exce√ß√£o do tipo ArgumentNullException.\nNo caso de uso, o m√©todo ReturnsSuccessOrFail pode receber dois tipos de valores, uma string ou ArgumentNullException. Depois de definido o valor, o m√©todo Match √© invocado para decidir qual a fun√ß√£o ser√° executada.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Arrange var usageCases = new UsageCases(); var value = \u0026#34;success case\u0026#34;; // Act var result = usageCases .ReturnsSuccessOrFail(value) .Match( success =\u0026gt; $\u0026#34;{success}\u0026#34;, error =\u0026gt; $\u0026#34;{error}\u0026#34;); // Assert Assert.Equal(value, result); Implementa√ß√£o Either A implementa√ß√£o do Either tem uma baixa complexidade. Utilizando generics, √© poss√≠vel definir um valor do tipo TL ou TR. Com uma sobrecarga de construtor para definir TL ou TR √© poss√≠vel marcar qual o lado que foi setado.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Either\u0026lt;TL, TR\u0026gt; { private readonly TL _left; private readonly TR _right; private readonly bool _isLeft; public Either(TL left) { _left = left; _isLeft = true; } public Either(TR right) { _right = right; _isLeft = false; } O m√©todo Match verifica se o objeto da esquerda est√° marcado. Se estiver marcado invoca a fun√ß√£o da esquerda, sen√£o a fun√ß√£o da direita.\n1 2 public T Match\u0026lt;T\u0026gt;(Func\u0026lt;TL, T\u0026gt; leftFunction, Func\u0026lt;TR, T\u0026gt; rightFunction) =\u0026gt; _isLeft ? leftFunction(_left) : rightFunction(_right); A utiliza√ß√£o de convers√£o impl√≠cita permite o uso do Either de forma idiom√°tica, o que √© visto na assinatura do m√©todo de exemplo.\n1 2 3 4 5 public static implicit operator Either\u0026lt;TL, TR\u0026gt;(TL left) =\u0026gt; new Either\u0026lt;TL, TR\u0026gt;(left); public static implicit operator Either\u0026lt;TL, TR\u0026gt;(TR right) =\u0026gt; new Either\u0026lt;TL, TR\u0026gt;(right); Manuten√ß√£o e Testes Uma vez que o Either trata os dois tipos, a necessidade de verifica√ß√£o de tipos ou verifica√ß√£o de nulos em cada ponto de retorno de um m√©todo √© eliminada. Isso reduz a chance de erros, uma vez que os poss√≠veis retornos fazem parte da assinatura do m√©todo. Essa estrat√©gia tamb√©m apoia os testes de unidade, justamente por n√£o ter as verifica√ß√µes de tipo e tratamento de nulls.\nFontes: https://github.com/thgbrb/monads\n","date":"2022-12-14T00:00:00Z","image":"https://joganacontadainfra.com.br/p/monad-either/saad-ahmad-BQLw0OrA6F4-unsplash_hu_5b82bb1f81bef059.jpg","permalink":"https://joganacontadainfra.com.br/p/monad-either/","title":"Monad Either"},{"content":"Sonarlint O sonarlint √© uma extens√£o free e opensource para as principais IDEs do mercado que ajuda a corrigir bugs no c√≥digo, aumentar a qualidade e detectar falhas de seguran√ßa. O Sonarlint faz a an√°lise est√°tica do c√≥digo, seja de um √∫nico arquivo ou de toda uma solu√ß√£o.\nO Sonarlint entrega algumas centenas de regras espec√≠ficas para cada tipo de linguagem suportada. Essas regras detectam bugs, code smell e vunerabilidades que podem ser introduzidas em tempo de codifica√ß√£o. O feedback √© instant√¢neo!\nConex√£o com SonarQube ou SonarCloud O Sonarlint pode ser conectado a inst√¢ncias do SonarQube ou SonarCloud. Essa configura√ß√£o permite receber as notifica√ß√µes de quality gates diretamente na IDE. Essa conex√£o tamb√©m importa as regras de quality gates definidas no SonarQube/SonarCloud do projeto e/ou de uma linguagem, ou seja, ap√≥s a conex√£o as regras passagem a ser analisadas diratemente na IDE. Al√©m do aumenta da qualidade de c√≥digo e conhecimento, ambos citados acima, essa integra√ß√£o permite ter o feedback do quality gate sem a necessidade da an√°lise da esteira de integra√ß√£o cont√≠nua.\nLinks e refer√™ncias Ferramenta Refer√™ncia Sonarlint https://www.sonarlint.org Extens√£o para Jetbrains https://plugins.jetbrains.com/plugin/7973-sonarlint#Jetbrains Extens√£o para Visual Studio 2022 https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022 Extens√£o para Visual Studio 2019 https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019 Extens√£o para Visual Studio 2017 https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2017 Extens√£o para Visual Studio Code https://marketplace.visualstudio.com/items?itemName=SonarSource.sonarlint-vscode Extens√£o para Eclipse https://marketplace.eclipse.org/content/sonarlint ","date":"2022-04-21T00:00:00Z","image":"https://joganacontadainfra.com.br/p/sonarlint/photo-1634128221889-82ed6efebfc3_hu_2105604f7418532e.jpg","permalink":"https://joganacontadainfra.com.br/p/sonarlint/","title":"Sonarlint"},{"content":"CPU Cache Os processadores possuem estrat√©gias de caching para manter as pr√≥ximas instru√ß√µes a serem executadas e blocos de dados a serem manipulados o mais pr√≥ximo de uma thread, economizando ciclos para buscar dados na mem√≥ria RAM; busca que no contexto de CPU √© extremamente lento. O cache de CPU √© distribu√≠do em n√≠veis, onde L1 √© um cache muito pequeno exclusivo para um core e compartilhado com as suas threads e o L2 √© um cache um pouco maior compartilhado por um grupo de core.\nCacheline O processador busca dados na mem√≥ria em blocos e n√£o ‚Äòbyte‚Äô a ‚Äòbyte‚Äô. Esses blocos de dados s√£o chamados de cacheline. Quando o processador l√™ um determinado ponto da mem√≥ria ele busca, a partir desse ponto, a quantidade de dados equivalentes ao tamanho da cacheline. Em m√©dia uma linha de cache possui 64 ‚Äòbytes‚Äô, variando de acordo com a arquitetura do processador. Quanto maior o tamanho do cache maior √© quantidade de linhas, ou seja, menor √© quantidade de leituras na mem√≥ria RAM.\nProcessador Cache L1 Cache L2 Cache L3 Lan√ßamento Pre√ßo i7-9750H 32K 256K 12M 2019 ~USD 395 Xeon E5-2620 384K 1,5M 15M 2012 ~USD 410 Tamanho do cache e cacheline\nPara verificar o tamanho do cache e cacheline em uma m√°quina com Windows, utilize o aplicativo Coreinfo da Sysinternal. Cache coherence protocol As CPUs modernas na sua maioria possuem mais de uma thread por core, utilizando t√©cnicas de programa√ß√£o paralela. Uma das estrat√©gias √© utilizar as micropausas de uma thread f√≠sica (ex.: buscar dados na mem√≥ria RAM) para que outra thread execute alguma opera√ß√£o.\nTecnologia propriet√°ria\nCada fornecedor define a sua tecnologia para maximizar o desempenho de um processador.\nIntel Hyper-thread AMD Simultaneous Multithreading As threads f√≠sicas compartilham o cache L1 exclusivo do seu core, assim como o cache L2, que √© compartilhado por um grupo de core e outros n√≠veis de cache possam existir. Por fim, acima dessa estrutura de cache, existe a mem√≥ria RAM.\nUso de cache sem coer√™ncia/integridade (fig wikip√©dia) Dado o cen√°rio de paralelismo, a CPU deve implementar estrat√©gias de sincroniza√ß√£o desses dados para evitar o problema demonstrado na imagem acima. Essa estrat√©gia √© chamada de Cache coherence protocol. Esse protocolo √© respons√°vel por manter a coer√™ncia e integridade no cache.\nEstrat√©gia de coer√™ncia (fig wikip√©dia) Otimiza√ß√£o de compiladores Os compiladores modernos al√©m gerarem c√≥digos que utilizam os recursos fornecidos pelas CPUs tamb√©m implementam estrat√©gias e t√©cnicas de otimiza√ß√£o, com o objetivo de extrair o m√°ximo do hardware. Por√©m, nem sempre os compiladores conseguem gerar o c√≥digo mais perform√°tico por uma s√©rie de motivos, que sozinhos s√£o tema de um futuro post. Dificilmente esses problemas s√£o detectados nos processos de desenvolvimento e/ou qualidade. N√£o √© incomum que eles ocorram somente em produ√ß√£o de forma n√£o determin√≠stica.\nFalse sharing Em algumas situa√ß√µes o c√≥digo de um programador n√£o consegue ser otimizado pelo compilador, o que introduz problemas de desempenho ou at√© mesmo falhas. Uma dessas situa√ß√µes √© o false sharing. O false sharing ocorre quando o cache coherence protocol entende ser necess√°rio atualizar uma determinada linha de cache, fazendo com que ocorra uma nova leitura do dado na mem√≥ria RAM. Lembrando que leitura de mem√≥ria RAM num contexto de CPU √© uma opera√ß√£o lenta!\nQuando threads f√≠sicas fazem leituras e grava√ß√µes frequentes de um dado muito pequeno que est√£o alinhados na mem√≥ria RAM num cen√°rio de paralelismo essa situa√ß√£o ocorrer√°.\nNos exemplos abaixo temos um c√≥digo cujo objetivo √© para cada posi√ß√£o de um array de inteiros incrementar o valor da refer√™ncia num ‚Äòlooping for‚Äô 1.000.000 de vezes.\nFoi utilizado um laptop com um processador i7-9750H para os testes.\nCen√°rio A - False sharing 17,435 segundos para finalizar o processamento.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private readonly int[] sharedArray = new int[4]; public void CenarioA() { var task1 = Task.Run(() =\u0026gt; Inc(0)); var task2 = Task.Run(() =\u0026gt; Inc(1)); var task3 = Task.Run(() =\u0026gt; Inc(2)); var task4 = Task.Run(() =\u0026gt; Inc(3)); Task.WaitAll(task1, task2, task3, task4); } private void Inc(int position) { for (var i = 0; i \u0026lt; 1_000_000; i++) sharedArray[position]++; } Cen√°rio B - Otimiza√ß√£o de c√≥digo 5,72 segundos para finalizar o processamento.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private readonly int[] sharedArray = new int[64]; public void CenarioB() { var task1 = Task.Run(() =\u0026gt; Inc(0)); var task2 = Task.Run(() =\u0026gt; Inc(16)); var task3 = Task.Run(() =\u0026gt; Inc(32)); var task4 = Task.Run(() =\u0026gt; Inc(48)); Task.WaitAll(task1, task2, task3, task4); } private void Inc(int position) { for (var i = 0; i \u0026lt; 1_000_000; i++) sharedArray[position]++; } Benchmark Cen√°rios A e B No benchmark observamos que o Cen√°rio B executou aproximadamente 3x mais r√°pido que o cen√°rio A.\nNo Cen√°rioA todas as threads compartilham a mesma cacheline para leitura e grava√ß√£o. Isso faz o cache coherence protocol invalidar diversas vezes a cacheline e consequentemente a CPU deve buscar na mem√≥ria RAM o valor atualizado. J√° no Cen√°rioB utilizamos uma estrat√©gia onde cada thread utiliza uma cacheline diferente! Para fazer isso √© utilizado saltos de 16 posi√ß√µes no array de inteiro, ou seja:\nQuantidade de Int32 Tamanho Int32 Tamanho ocupado 16 4 bytes 16 x 4 bytes = 64 bytes Considerando que o processador onde o benchmark √© executado possui uma cacheline de 64 ‚Äòbytes‚Äô, cada thread utilizar√° uma cacheline diferente.\nConclus√£o Apesar dos compiladores ocultarem parte da complexidade da programa√ß√£o paralela h√° cen√°rios que precisam da interven√ß√£o do programador. Entender como funciona aloca√ß√£o de mem√≥ria na sua stack de desenvolvimento assim como conhecer o funcionamento de componentes de hardware s√£o ferramentas essenciais para a escrita de c√≥digos de alto desempenho e otimizados.\nüëâ Dica ‚ò†Ô∏è\nOtimiza√ß√£o prematura do c√≥digo traz complexidade sem agregar valor! Evite :)\nü§Ø Informa√ß√£o\nFalse sharing √© um problema universal em processadores multithreading que compartilham cache. O exemplo acima funciona em qualquer linguagem :)\n","date":"2021-07-15T00:00:00Z","image":"https://joganacontadainfra.com.br/p/cache-line-false-sharing/cacheline_hu_b0d6b8fe93291c66.png","permalink":"https://joganacontadainfra.com.br/p/cache-line-false-sharing/","title":"Cachelines e False Sharing"},{"content":"Durante um apoio a projeto me deparei com o seguinte cen√°rio quando acessei git log:\n1 2 3 4 5 6 7 8 9 10 11 12 13 391a8dad Elabora√ß√£o dos contadores de performance para os comando da Api Pedidos fdde9224 Merge branch \u0026#39;release/v8.0.3\u0026#39; of https://dev.azure.com/XXXXXXXXXXXXXX/v8.0.3 3c2b525f publica√ß√µes a3cb5825 merge apresenta√ß√£o da url do boleto com o desconto do cupom frete enviado ao ax f9852c90 ajuste para mandar o valor de desconto do cupom tipo frete correto ao ax 64785991 Pedidos: Exibindo o link do Pdf no n√≥ de boleto de cobran√ßa + XXXXXX.Produtos: ajuste no nome de um dos eventos do contador de performance + XXXXXX.YYYYYYYY: exibi√ß√£o do link do Pdf do boleto c9c79c0d publica√ßoes 07570cf7 CatalogoDeProdutos: CatalogoDeProdutosPerformanceMonitor herda a interface IPerformanceMonitor f113e074 Conflict resolution 424246b0 Update azure-pipelines-unit.yml for Azure Pipelines d0e870bd Update azure-pipelines-unit.yml for Azure Pipelines 8c5255d2 Update azure-pipelines-unit.yml for Azure Pipelines 7fdf5e97 Update azure-pipelines-unit.yml for Azure Pipelines A situa√ß√£o do hist√≥rico era t√£o ca√≥tica que era quase imposs√≠vel entender qual o prop√≥sito de um commit, tornando in√∫til a sua descri√ß√£o. A hist√≥ria daquele fonte estava muito mal contada e √© a√≠ que est√° o problema. Quando era necess√°rio entender a implementa√ß√£o de uma regra de neg√≥cio ou o que motivou as altera√ß√µes no c√≥digo n√£o existia contexto, n√£o existia hist√≥ria. Uma sequ√™ncia de commits com o mesmo t√≠tulo \u0026ldquo;Update azure-pipelines-unit.yml for Azure Pipelines\u0026rdquo; n√£o deixa claro o motivo da altera√ß√£o. Apenas sabemos que ocorreu uma sequ√™ncia de altera√ß√µes em um arquivo.\nA falta de rela√ß√£o do commit com uma issue em uma ferramenta ALM contribu√≠a para a falta de contexto. Em algumas situa√ß√µes era necess√°rio recorrer ao time de neg√≥cio para resgatar o hist√≥rico que motivou a altera√ß√£o de uma regra de neg√≥cio.\nOs commits em um reposit√≥rio git contam uma hist√≥ria, a hist√≥ria de vida de um c√≥digo. Eles descrevem o que motivou a fazer as altera√ß√µes que foram feitas de uma forma muito clara, mantendo o hist√≥rico e apoiando os futuros desenvolvedores.\nUm commit bem escrito √© dividido em duas partes, o assunto com no m√°ximo 50 caracteres e que de forma imperativa expressa a sua inten√ß√£o e um body que descreve o porqu√™ do commit. Um bom commit tamb√©m faz refer√™ncia ou est√° vinculado a uma issue que contextualiza o commit. No exemplo abaixo, √© poss√≠vel verificar algumas boas pr√°ticas na escrita de commits aplicadas no reposit√≥rio do Erlang.\n1 2 3 4 5 6 7 8 9 10 21b7ad04ce Clarify the asynchronousness of signal reception 5b762b79a4 erts: Document hibernate resume function must be exported 18e9843e44 Improve receive docs 410b279d41 erts: Fix super alignment in etp-commands f0ae5f12d6 erts: Short circuit immediates in match spec compiler 220a46789e erts: Micro optimize arityval -\u0026gt; make_arityval f12067111a erts: Silence harmless compiler warnings 68cfb519ca erts: Optimize erts_qsort_partion_array e01cfccd2f crypto: Test generated EC private key length 18fa73579d dialyzer: Do not expose line number 0 in message locations O projeto Erlang possui uma qualidade alta na escrita de seus commits. No exemplo abaixo o assunto demonstra a inten√ß√£o e no body o porqu√™.\nExemplo de um commit com boas pr√°ticas\n1 2 3 4 5 6 7 Don\u0026#39;t keep a stacktrace longer than necessary After an exception had been caught, the stacktrace (`p-\u0026gt;ftrace`) would be retained in the process until another exception occurred. While at it, also clear the exception term (`p-\u0026gt;fvalue`) in the common error handling code instead of in the code for `try_case` in each module Guia de Boas Pr√°ticas Mais do que uma simples descri√ß√£o, as boas pr√°ticas na escrita de commit servem para apoiar o processo de revis√£o, contribuir para um release notes rico e ajudar os futuros desenvolvedores.\nO commit √© composto por um assunto e um body opcional. Sempre mantenha uma linha em branco entre o assunto e body quando existir um. N√£o utilize ponto final no final do assunto. Mantenha o assunto com no m√°ximo 50 caracteres. Utilize o body para explicar o que foi feito ao inv√©s de como foi feito. D√™ prefer√™ncia para uma linguagem imperativa no assunto. Relacione as issues no final do body. Conhe√ßa o git (squash √© um excelente exemplo). Respeite os padr√µes acordados com o time. Para mais informa√ß√µes acesse o git book.\n","date":"2021-07-08T00:00:00Z","image":"https://joganacontadainfra.com.br/p/boas-praticas-em-commits/featured_hu_dcac20f0f2ffa531.jpg","permalink":"https://joganacontadainfra.com.br/p/boas-praticas-em-commits/","title":"Boas pr√°ticas em commits"},{"content":"O problema Quem nunca ouviu alguma dessas frases:\n\u0026quot;...sua aplica√ß√£o deve ser ass√≠ncrona...\u0026quot;, \u0026quot;...se est√° lento muda o m√©todo para async...\u0026quot;, \u0026quot;...todos os m√©todos da API devem ser ass√≠ncronos...\u0026quot;, \u0026quot;...usa async para tentar resolver o problema de lentid√£o\u0026quot;, \u0026quot;Eu li num blog que aplica√ß√µes modernas em C# devem ser async/await...\u0026quot;. No final de tudo, encontramos esse tipo de c√≥digo na aplica√ß√£o:\n1 2 3 4 5 6 public static Task DoRequest(string url) =\u0026gt; Task.Run(async () =\u0026gt; { await httpClient.GetStringAsync(requestUri: url); Console.WriteLine($\u0026#34;{DateTime.Now} - Task completed.\u0026#34;); }); IO Bound \u0026amp; CPU Bound Dentro da computa√ß√£o, IO Bound refere-se a cargas de trabalho de IO (disco, redes, dispositivos) e CPU Bound √†s cargas de trabalho de CPU (algoritmos, c√°lculos).\nMicrosoft Windows e IO Bound Conceitualmente, toda a carga de trabalho de uma aplica√ß√£o √© executada por uma thread. Essa thread possui uma fatia de tempo (time slice) de uso do processador.\nAgora, se aplica√ß√£o faz o acesso a um IO, porque deve existir uma thread?\nDe fato, n√£o faz sentido. Por esse motivo o Windows, em sua natureza ass√≠ncrona, trata esse cen√°rio de IO Bound. Toda chamada para o Windows, mesmo que s√≠ncrona, ser√° tratada como ass√≠ncrona. Quando o .NET acessa um recurso de IO, ele cria uma IOCP (IO Completation Port) vinculada ao chamador. O .NET utiliza as IOCP para gerenciar as solicita√ß√µes de IO realizadas pela aplica√ß√£o. Na sequencia o .NET faz acesso a API Win32, cria um IRP (IO Request Packet) e adiciona-o na fila do dispositivo. O IRP faz parte da arquitetura do Windows, e √© utilizado para comunica√ß√£o com dispositivos. Nessa arquitetura, √© utilizado uma fila IRP para o dispositivo, que retira o pacote da fila, processa o trabalho e devolve o resultado.\nObserve que nesse processo, n√£o h√° thread envolvida. √â puramente IO!\nUma vez que o trabalho √© conclu√≠do, o dispositivo faz uma chamada de interrup√ß√£o de sistema e devolve o resultado. Quando isso acontece, a API Win32 ir√° obter o resultado do trabalho e notificar√° o .NET atrav√©s da IOCP criada na requisi√ß√£o. Nesse momento, o .NET ir√° obter uma thread do ThreadPool e devolver√° o resultado para o chamador.\n.NET e IO Bound Uma vez que entendemos essa arquitetura, fica claro porque as chamadas ass√≠ncronas precisam ser \u0026ldquo;async all the way\u0026rdquo; e principalmente, porque n√£o h√° threads em IO Bound.\nQuando olhamos novamente o c√≥digo, fica claro porque ele n√£o faz sentido.\n1 2 3 4 5 6 public static Task DoRequest(string url) =\u0026gt; Task.Run(async () =\u0026gt; { await httpClient.GetStringAsync(requestUri: url); Console.WriteLine($\u0026#34;{DateTime.Now} - Task completed.\u0026#34;); }); Como essa chamada √© s√≠ncrona, o httpclient manter√° a thread bloqueada at√© finalizar o request, ou seja, nesse c√≥digo estamos alocando uma Task e sua estrutura de m√°quina de estado para aguardar uma thread que sabemos que ficar√° bloqueada. Neste caso, onde a chamada √© s√≠ncrona, e h√° somente m√©todos ass√≠ncronos dispon√≠veis na API, ent√£o usamos .Result.\n1 2 3 4 5 public static void DoRequest(string url) { httpClient.GetStringAsync(requestUri: url).Result; Console.WriteLine($\u0026#34;{DateTime.Now} - Task completed.\u0026#34;); }; Para utilizar chamadas ass√≠ncronas em .NET √© necess√°rio que:\nChamada seja \u0026ldquo;async all the way\u0026rdquo; Lib de acesso ao recurso implemente \u0026ldquo;async all the way\u0026rdquo; Se qualquer uma dessas condi√ß√µes n√£o for atendida, o seu c√≥digo estar√° bloqueando uma thread para cargas de trabalho IO Bound.\nDemostra√ß√£o do Impacto do IO Bound Para materializar a import√¢ncia do IO Bound na aplica√ß√£o e o seu impacto, vamos analisar a PoC abaixo.\nTimeApi O TimeApi √© uma API Rest em .NET Core que possui um m√©todo GET que retorna um DateTime atual. Antes de retornar o DateTime ele uso um delay aleat√≥rio de 10s at√© 20s a fim de simular uma API com problemas de performance. Portal O Portal √© uma aplica√ß√£o ASPNET Core que possui 3 actions, sendo a Index (faz uma chamada s√≠ncrona para TimeApi), a IndexAsync (faz uma chamada ass√≠ncrona para TimeApi) e a Information (retorna a quantidade de threads dispon√≠veis na aplica√ß√£o). A aplica√ß√£o Portal possui uma restri√ß√£o de threads dispon√≠veis, limitada ao n√∫mero de cores do processador da m√°quina da demostra√ß√£o (8 cores). Isso √© utilizado para simular um servidor com alta carga de trabalho e poucas threads dispon√≠veis. Requester O Requester √© uma aplica√ß√£o console em .NET Core que faz chamadas s√≠ncronas e ass√≠ncronas para o Portal. Na chamada s√≠ncrona, bloqueamos uma thread, que fica aguardando finalizar a carga de trabalho IO.\nJ√° na chamada ass√≠ncrona, com o \u0026ldquo;async all the way\u0026rdquo;, as threads n√£o s√£o bloqueadas. Assim que invocamos o HttpClient, ele segue o fluxo de processamento ass√≠ncrono que vimos acima e libera a thread do request para retornar ao Threadpool. Desta forma, mesmo que a TimeApi apresente algum problema de performance, a aplica√ß√£o Portal fica dispon√≠vel para receber novos requests.\nCusto da programa√ß√£o Ass√≠ncrona Quando uma aplica√ß√£o apresenta lentid√£o, a resposta default, na maioria dos casos √© \u0026ldquo;\u0026hellip; precisamos de mais hardware.\u0026rdquo;. De fato, o aumento do hardware minimiza os problemas de performance, mas √† um alto custo financeiro. Na demonstra√ß√£o, onde simulamos um ambiente com hardware limitado e/ou carga alta de trabalho e com uma API problem√°tica, observamos que utilizando as chamadas ass√≠ncronas corretamente, fomos capazes de atender 305 requisi√ß√µes! Comparando com o total de requisi√ß√µes s√≠ncronas obtidas, que foram 14, significa que a aplica√ß√£o ass√≠ncrona foi 22x mais eficiente no uso do hardware.\nSe considerarmos que nesse cen√°rio hipot√©tico, a aplica√ß√£o deve atender at√© 305 requests, concluimos que:\nNa vers√£o s√≠ncrona precisar√≠amos de 14 servidores; Na vers√£o ass√≠ncrona, os 14 servidores da vers√£o s√≠ncrona poderiam ser reduzidos para 1 √∫nico servidor. Considerando o custo de um servidor f√≠sico de BRL 12.000, concluimos que:\nO custo de infraestrutura para vers√£o s√≠ncrona seria de BRL 168.000; O custo de infraestrutura para vers√£o ass√≠ncrona seria de BRL 12.000. Reflex√£o Mais do que um software funcional, √© necess√°rio que ele seja eficiente e respons√°vel. Devemos conhecer como o Framework que trabalhamos funciona. Devemos aprender a escrever c√≥digo que aproveite o m√°ximo poss√≠vel o hardware dispon√≠vel.\nOs fontes utilizados nesse artigo, est√£o dispon√≠veis no Github.\n","date":"2019-08-11T00:00:00Z","image":"https://joganacontadainfra.com.br/p/io-bound-there-is-no-thread/featured_hu_5dc9d51cbb0a76dd.jpg","permalink":"https://joganacontadainfra.com.br/p/io-bound-there-is-no-thread/","title":"IO Bound - There is no thread \u003c0\u003e"},{"content":"Quando uma aplica√ß√£o, principalmente legada, demostra problemas de performance, a primeira solu√ß√£o que vem na cabe√ßa √© paralelismo. Com o paralelismo vem a TPL e consequentemente o m√©todo Task.Run. Veja esse m√©todo:\n1 2 3 4 public static Task\u0026lt;List\u0026lt;InsulinDosageComplement\u0026gt;\u0026gt; GetAllAsync() { return Task.Run(() =\u0026gt; new InsulinDosageComplementWrapper().GetAll()); } Esse √© o erro mais comum na utiliza√ß√£o da TPL. O que esse m√©todo faz √© criar uma nova Task. N√£o h√° m√°gica, √© isso! O m√©todo que √© passado como par√¢metro do m√©todo Run ser√° executado em uma thread existente ou uma nova thread ser√° criada.\nSe considerarmos a chamada desse m√©todo em qualquer que seja o contexto, esse m√©todo ir√° consumir uma thread sem necessidade. O mais curioso √© que o c√≥digo que consome o m√©todo acima n√£o utiliza await, ele utiliza .Result, ou seja, a thread do request fica bloqueada aguardando uma outra thread processar a chamada.\nCertamente Task.Run n√£o √© a solu√ß√£o para problemas de performance se n√£o for bem utilizada. Por isso, se voc√™ estiver pensando em utilizar Task.Run e est√° com d√∫vida, N√£o use!\n","date":"2019-07-03T00:00:00Z","image":"https://joganacontadainfra.com.br/p/esta-com-duvida-no-uso-do-task-run-nao-use/featured_hu_6b9f5930ad7da93e.jpg","permalink":"https://joganacontadainfra.com.br/p/esta-com-duvida-no-uso-do-task-run-nao-use/","title":"Est√° com d√∫vida no uso do Task.Run? N√ÉO USE!"}]